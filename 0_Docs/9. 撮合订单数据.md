
- [给出挂单卖NFT，戳和成交前后的数据结构](#给出挂单卖nft戳和成交前后的数据结构)
	- [1. 挂单阶段数据结构](#1-挂单阶段数据结构)
	- [2. 戳（Match）阶段数据结构](#2-戳match阶段数据结构)
	- [3. 成交后数据结构](#3-成交后数据结构)
	- [4. 状态变化说明](#4-状态变化说明)
		- [挂单时：](#挂单时)
		- [戳单时：](#戳单时)
		- [成交后：](#成交后)
	- [5. 关键字段说明](#5-关键字段说明)
- [MarketplaceId是怎么来的](#marketplaceid是怎么来的)
	- [1. 定义位置](#1-定义位置)
	- [2. 使用场景](#2-使用场景)
	- [3. 数据库表结构](#3-数据库表结构)
	- [4. 业务含义](#4-业务含义)
	- [5. 相关代码位置](#5-相关代码位置)

# 给出挂单卖NFT，戳和成交前后的数据结构


根据代码分析，我来展示挂单卖NFT在不同阶段的数据结构：

## 1. 挂单阶段数据结构

```solidity
struct Order {
    uint8 Side;              // 订单方向，卖单为1
    uint8 SaleKind;          // 销售类型，FixForCollection为0，FixForItem为1
    address Maker;          // 卖家地址
    struct {
        uint256 TokenId;    // NFT的Token ID
        address CollectionAddr; // NFT集合合约地址
        uint256 Amount;     // 数量
    } Nft;
    uint256 Price;          // 挂单价格
    uint64 Expiry;         // 过期时间戳
    uint64 Salt;           // 随机数
}
```

## 2. 戳（Match）阶段数据结构

```solidity
struct MatchOrder {
    Order makeOrder;        // 原始挂单
    Order takeOrder;        // 接单
    uint256 fillPrice;      // 实际成交价格
    uint256 fillAmount;     // 成交数量
}
```

## 3. 成交后数据结构

```go
// 在EasySwapSync/service/orderbookindexer/service.go中的handleMatchEvent函数
type Order struct {
    CollectionAddress string    // NFT集合合约地址
    MarketplaceId    int64     // 市场ID
    TokenId          string    // NFT的Token ID
    OrderID          string    // 订单唯一标识
    OrderStatus      int64     // 订单状态：1=Active, 2=Filled, 3=Cancelled
    EventTime        int64     // 订单创建时间
    ExpireTime       int64     // 订单过期时间
    CurrencyAddress  string    // 支付代币合约地址
    Price            decimal   // 订单价格
    Maker            string    // 订单创建者地址
    Taker            string    // 订单接收者地址
    QuantityRemaining int64    // 剩余数量
    Size             int64     // 订单大小
    OrderType        int64     // 订单类型：1=Listing, 2=Offer, 3=CollectionBid, 4=ItemBid
    Salt             int64     // 随机数
}
```

## 4. 状态变化说明

### 挂单时：
- `OrderStatus` = 1 (Active)
- `QuantityRemaining` = `Size` (初始数量)
- `Taker` = ZeroAddress (空地址)

### 戳单时：
- 创建`MatchOrder`结构体
- 记录`fillPrice`和`fillAmount`

### 成交后：
- `OrderStatus` = 2 (Filled)
- `QuantityRemaining` = 0 (已全部成交)
- `Taker` = 买家地址
- 记录到Activity表中，`activity_type` = 7 (Sell)

## 5. 关键字段说明

1. `Side`:
   - 0: 买单
   - 1: 卖单

2. `SaleKind`:
   - 0: FixForCollection（不指定具体NFT）
   - 1: FixForItem（指定具体NFT）

3. `OrderStatus`:
   - 1: Active（活跃状态）
   - 2: Filled（已成交）
   - 3: Cancelled（已取消）

4. `OrderType`:
   - 1: Listing（卖单）
   - 2: Offer（报价）
   - 3: CollectionBid（集合买单）
   - 4: ItemBid（单品买单）

这些数据结构通过合约的`makeOrder`和`takeOrder`函数进行创建和更新，所有状态变化都会记录在Activity表中。

# MarketplaceId是怎么来的


根据代码分析，MarketplaceId的来源如下：

## 1. 定义位置
在 `EasySwapSync/service/orderbookindexer/service.go` 中定义了常量：
```go
const (
    MarketOrderBook = 0  // 订单簿市场的ID
)
```

## 2. 使用场景
在创建订单时，MarketplaceId被设置为固定值0：
```go
// 在handleMakeEvent函数中
order := multi.Order{
    MarketplaceId: multi.MarketOrderBook,  // 固定为0
    // ...其他字段
}
```

## 3. 数据库表结构
在数据库表 `ob_order_sepolia` 中，`marketplace_id` 字段定义：
```sql
marketplace_id tinyint default 0 not null comment '0.local',
```

## 4. 业务含义
- MarketplaceId = 0 表示这是本地订单簿市场的订单
- 这是一个固定的标识符，用于区分不同市场的订单
- 目前系统只支持一个市场（订单簿市场），所以固定为0

## 5. 相关代码位置
- 定义：`EasySwapSync/service/orderbookindexer/service.go`
- 使用：`EasySwapSync/service/orderbookindexer/service.go` 的 `handleMakeEvent` 函数
- 数据库：`ob_order_sepolia` 表的 `marketplace_id` 字段

这个设计允许未来扩展支持多个市场，但目前只使用一个固定的市场ID（0）。