
- [一、卖单卖NFT数据组装](#一卖单卖nft数据组装)
	- [卖单数据结构](#卖单数据结构)
	- [两种卖单类型的区别](#两种卖单类型的区别)
		- [1. FixForCollection（集合卖单）](#1-fixforcollection集合卖单)
		- [2. FixForItem（单品卖单）](#2-fixforitem单品卖单)
	- [关键字段说明](#关键字段说明)


# 一、卖单卖NFT数据组装
根据代码分析，我来展示Solidity中卖单数据的结构：

## 卖单数据结构

```solidity
struct Order {
    uint8 Side;              // 订单方向，卖单为1
    uint8 SaleKind;          // 销售类型，FixForCollection为0，FixForItem为1
    address Maker;          // 卖家地址
    struct {
        uint256 TokenId;    // NFT的Token ID
        address CollectionAddr; // NFT集合合约地址
        uint256 Amount;     // 数量
    } Nft;
    uint256 Price;          // 挂单价格
    uint64 Expiry;         // 过期时间戳
    uint64 Salt;           // 随机数
}
```

## 两种卖单类型的区别

### 1. FixForCollection（集合卖单）
```solidity
Order memory collectionListing = Order({
    Side: 1,  // 卖单
    SaleKind: 0,  // FixForCollection
    Maker: 0x...,  // 卖家地址
    Nft: NftInfo({
        TokenId: 0,  // 固定为0
        CollectionAddr: 0x...,  // NFT集合合约地址
        Amount: 1
    }),
    Price: 0.1 ether,
    Expiry: uint64(block.timestamp + 86400),  // 24小时后过期
    Salt: uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender)))
});
```

### 2. FixForItem（单品卖单）
```solidity
Order memory itemListing = Order({
    Side: 1,  // 卖单
    SaleKind: 1,  // FixForItem
    Maker: 0x...,  // 卖家地址
    Nft: NftInfo({
        TokenId: 123,  // 指定的Token ID
        CollectionAddr: 0x...,  // NFT集合合约地址
        Amount: 1
    }),
    Price: 0.2 ether,
    Expiry: uint64(block.timestamp + 86400),  // 24小时后过期
    Salt: uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender)))
});
```

## 关键字段说明

1. `Side`:
   - 0: 买单
   - 1: 卖单

2. `SaleKind`:
   - 0: FixForCollection（不指定具体NFT）
   - 1: FixForItem（指定具体NFT）

3. `Nft.TokenId`:
   - FixForCollection: 必须为0
   - FixForItem: 指定具体的Token ID

4. `Expiry`:
   - Unix时间戳格式
   - 必须大于当前时间

5. `Salt`:
   - 用于生成唯一订单ID
   - 建议使用时间戳和用户地址的组合

这些数据结构需要通过合约的`makeOrder`函数提交，并需要 maker 的签名验证。