
- [订单数据结构](#订单数据结构)
	- [1. QuantityRemaining (剩余数量)](#1-quantityremaining-剩余数量)
	- [2. Size (订单总数量)](#2-size-订单总数量)
	- [3. OrderType (订单类型)](#3-ordertype-订单类型)
		- [. 字段关联关系](#-字段关联关系)
		- [. 实际应用场景](#-实际应用场景)
	- [4. EventTime (订单创建时间)](#4-eventtime-订单创建时间)
	- [5. ExpireTime (订单过期时间)](#5-expiretime-订单过期时间)
	- [6. CurrencyAddress (支付代币合约地址)](#6-currencyaddress-支付代币合约地址)
		- [. 字段关联关系](#-字段关联关系-1)
		- [. 实际应用场景](#-实际应用场景-1)

# 订单数据结构
```go
// 在EasySwapSync/service/orderbookindexer/service.go中的handleMatchEvent函数
type Order struct {
    CollectionAddress string    // NFT集合合约地址
    MarketplaceId    int64     // 市场ID
    TokenId          string    // NFT的Token ID
    OrderID          string    // 订单唯一标识
    OrderStatus      int64     // 订单状态：1=Active, 2=Filled, 3=Cancelled
    EventTime        int64     // 订单创建时间
    ExpireTime       int64     // 订单过期时间
    CurrencyAddress  string    // 支付代币合约地址
    Price            decimal   // 订单价格
    Maker            string    // 订单创建者地址
    Taker            string    // 订单接收者地址
    QuantityRemaining int64    // 剩余数量
    Size             int64     // 订单大小
    OrderType        int64     // 订单类型：1=Listing, 2=Offer, 3=CollectionBid,4=ItemBid
    Salt             int64     // 随机数
}
```

根据代码分析，我来详细解释这三个字段的意义：

## 1. QuantityRemaining (剩余数量)
- 表示订单中尚未成交的NFT数量
- 初始值等于Size，随着交易发生而减少
- 当QuantityRemaining为0时，表示订单已完全成交
- 在`handleMatchEvent`中可以看到更新逻辑：
```go
if buyOrder.QuantityRemaining > 1 {
    // 部分成交时减少剩余数量
    Update("quantity_remaining", buyOrder.QuantityRemaining-1)
} else {
    // 完全成交时设为0
    Updates(map[string]interface{}{
        "quantity_remaining": 0
    })
}
```

## 2. Size (订单总数量)
- 表示订单创建时的NFT总数量
- 对于ERC721通常为1
- 对于ERC1155可能大于1
- 在订单生命周期中保持不变
- 初始化时从事件数据获取：
```go
Size: event.Nft.Amount.Int64()
```

## 3. OrderType (订单类型)
- 标识订单的具体类型，有四种可能的值：1=Listing, 2=Offer, 3=CollectionBid,4=ItemBid
```go
// 在handleMakeEvent中的类型判断
if side == Bid { // 买单
    if saleKind == FixForCollection {
        orderType = multi.CollectionBidOrder  // 3: 集合出价
    } else {
        orderType = multi.ItemBidOrder        // 4: 单品出价
    }
} else { // 卖单
    orderType = multi.ListingOrder           // 1: 挂单
}
```

### . 字段关联关系
- Size是订单的初始总量
- QuantityRemaining是当前剩余量
- OrderType决定了订单的行为规则
- 这三个字段共同决定了订单的状态和可执行的操作

### . 实际应用场景
- ERC721交易：Size=1, QuantityRemaining从1递减到0
- ERC1155批量交易：Size=n, QuantityRemaining从n递减到0
- 不同OrderType对应不同的交易逻辑和展示方式

这些字段的设计使得系统能够灵活处理不同类型的NFT交易需求，同时准确追踪订单状态。

---


根据代码分析，我来详细解释这三个字段的意义：

## 4. EventTime (订单创建时间)
- 表示订单在链上创建的时间戳
- 在`handleMakeEvent`中获取：
```go
EventTime: time.Now().Unix()
```
- 用于：
  - 记录订单创建时间
  - 计算订单有效期
  - 排序和查询历史订单

## 5. ExpireTime (订单过期时间)
- 表示订单的有效期截止时间戳
- 在订单创建时设置：
```go
ExpireTime: int64(event.Expiry)
```
- 用于：
  - 判断订单是否有效
  - 自动清理过期订单
  - 在`loadOrdersToQueue`中检查：
```go
if order.ExpireTime < time.Now().Unix() { // 已过期
    expiredOrderIDs = append(expiredOrderIDs, order.ID)
}
```

## 6. CurrencyAddress (支付代币合约地址)
- 标识用于支付的代币合约地址
- 在订单创建时设置：
```go
CurrencyAddress: s.cfg.ContractCfg.EthAddress
```
- 用于：
  - 指定支付币种
  - 计算实际支付金额
  - 区分不同币种的订单

### . 字段关联关系
- EventTime和ExpireTime共同决定订单有效期
- CurrencyAddress影响订单的支付方式
- 这三个字段都是订单的基本属性，在订单创建时确定

### . 实际应用场景
- 订单生命周期管理：通过EventTime和ExpireTime控制订单状态
- 多币种支持：通过CurrencyAddress支持不同代币交易
- 订单查询：可以使用这些字段进行订单筛选和排序

这些字段的设计使得系统能够准确管理订单生命周期，同时支持多币种交易需求。


