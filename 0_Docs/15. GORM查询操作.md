- [1. 单条记录查询](#1-单条记录查询)
	- [First查询](#first查询)
	- [特点：](#特点)
- [2. 条件查询](#2-条件查询)
	- [Where条件](#where条件)
	- [Raw SQL查询](#raw-sql查询)
- [3. 更新操作](#3-更新操作)
	- [单字段更新](#单字段更新)
	- [多字段更新](#多字段更新)
- [4. 防重复插入](#4-防重复插入)
	- [OnConflict处理](#onconflict处理)
- [5. 批量操作](#5-批量操作)
	- [批量插入](#批量插入)
- [关键特性](#关键特性)

根据代码库分析，GORM查询操作主要分为以下几类：

## 1. 单条记录查询

### First查询
```go
// service.go:handleCancelEvent
var cancelOrder multi.Order
if err := s.db.WithContext(s.ctx).Table(multi.OrderTableName(s.chain)).
    Where("order_id = ?", orderId).
    First(&cancelOrder).Error; err != nil {
    xzap.WithContext(s.ctx).Error("failed on get cancel order",
        zap.Error(err))
    return
}
```

### 特点：
- 使用First查询单条记录
- 如果找不到记录会返回gorm.ErrRecordNotFound错误
- 需要处理错误情况

## 2. 条件查询

### Where条件
```go
// service.go:handleMatchEvent
if err := s.db.WithContext(s.ctx).Table(multi.OrderTableName(s.chain)).
    Where("order_id = ?", takeOrderId).
    Updates(map[string]interface{}{
        "order_status":       multi.OrderStatusFilled,
        "quantity_remaining": 0,
        "taker":              to,
    }).Error; err != nil {
    xzap.WithContext(s.ctx).Error("failed on update order status",
        zap.String("order_id", takeOrderId))
    return
}
```

### Raw SQL查询
```go
// service.go:QueryCollectionsFloorPrice
sql := fmt.Sprintf(`SELECT co.collection_address as collection_address,min(co.price) as price
FROM %s as ci
         left join %s co on co.collection_address = ci.collection_address and co.token_id = ci.token_id
WHERE (co.order_type = ? and
       co.order_status = ? and expire_time > ? and co.maker = ci.owner) group by co.collection_address`, 
    gdb.GetMultiProjectItemTableName(s.cfg.ProjectCfg.Name, s.chain), 
    gdb.GetMultiProjectOrderTableName(s.cfg.ProjectCfg.Name, s.chain))
if err := s.db.WithContext(s.ctx).Raw(
    sql,
    multi.ListingType,
    multi.OrderStatusActive,
    time.Now().Unix(),
).Scan(&collectionFloorPrice).Error; err != nil {
    return nil, errors.Wrap(err, "failed on get collection floor price")
}
```

## 3. 更新操作

### 单字段更新
```go
// service.go:handleMatchEvent
if err := s.db.WithContext(s.ctx).Table(multi.OrderTableName(s.chain)).
    Where("order_id = ?", makeOrderId).
    Update("quantity_remaining", buyOrder.QuantityRemaining-1).Error; err != nil {
    xzap.WithContext(s.ctx).Error("failed on update order quantity_remaining",
        zap.String("order_id", makeOrderId))
    return
}
```

### 多字段更新
```go
// service.go:handleMatchEvent
if err := s.db.WithContext(s.ctx).Table(multi.OrderTableName(s.chain)).
    Where("order_id = ?", makeOrderId).
    Updates(map[string]interface{}{
        "order_status":       multi.OrderStatusFilled,
        "quantity_remaining": 0,
    }).Error; err != nil {
    xzap.WithContext(s.ctx).Error("failed on update order status",
        zap.String("order_id", makeOrderId))
    return
}
```

## 4. 防重复插入

### OnConflict处理
```go
// service.go:handleMakeEvent
if err := s.db.WithContext(s.ctx).Table(multi.OrderTableName(s.chain)).Clauses(clause.OnConflict{
    DoNothing: true,
}).Create(&newOrder).Error; err != nil {
    xzap.WithContext(s.ctx).Error("failed on create order",
        zap.Error(err))
}
```

## 5. 批量操作

### 批量插入
```go
// service.go:persistCollectionsFloorChange
for i := 0; i < len(FloorPrices); i += comm.DBBatchSizeLimit {
    end := i + comm.DBBatchSizeLimit
    if i+comm.DBBatchSizeLimit >= len(FloorPrices) {
        end = len(FloorPrices)
    }

    valueStrings := make([]string, 0)
    valueArgs := make([]interface{}, 0)

    for _, t := range FloorPrices[i:end] {
        valueStrings = append(valueStrings, "(?,?,?,?,?)")
        valueArgs = append(valueArgs, t.CollectionAddress, t.Price, t.EventTime, t.CreateTime, t.UpdateTime)
    }

    stmt := fmt.Sprintf(`INSERT INTO %s (collection_address,price,event_time,create_time,update_time)  VALUES %s
    ON DUPLICATE KEY UPDATE update_time=VALUES(update_time)`, 
    gdb.GetMultiProjectCollectionFloorPriceTableName(s.cfg.ProjectCfg.Name, s.chain), 
    strings.Join(valueStrings, ","))

    if err := s.db.Exec(stmt, valueArgs...).Error; err != nil {
        return errors.Wrap(err, "failed on persist collection floor price info")
    }
}
```

## 关键特性

1. **上下文支持**：所有操作都使用`WithContext(s.ctx)`支持上下文
2. **错误处理**：每个操作都有对应的错误处理逻辑
3. **表名动态**：使用`TableName(s.chain)`动态生成表名
4. **批量处理**：使用`DBBatchSizeLimit`控制批量操作大小
5. **防重复**：使用`OnConflict`处理重复数据

这些操作展示了GORM在项目中的主要使用模式，包括查询、更新、批量操作等常见场景。