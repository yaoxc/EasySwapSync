
- [order匹配](#order匹配)
	- [Solidity](#solidity)
	- [区别 Nft.CollectionAddr字段怎么匹配上的Solidity中的collection字段](#区别-nftcollectionaddr字段怎么匹配上的solidity中的collection字段)
		- [1. 在 `EasySwapSync/service/orderbookindexer/service.go` 中，通过 ABI 解析日志数据：](#1-在-easyswapsyncserviceorderbookindexerservicego-中通过-abi-解析日志数据)
		- [2. 字段匹配规则：](#2-字段匹配规则)
		- [3. 类型转换：](#3-类型转换)
		- [4. 合约 ABI 定义（在 `contractAbi` 常量中）确保了字段名的正确映射：](#4-合约-abi-定义在-contractabi-常量中确保了字段名的正确映射)
- [collection 和 collectionAddr名字不一样，也可以匹配上么?](#collection-和-collectionaddr名字不一样也可以匹配上么)
	- [1. 在 `service.go` 中，通过 ABI 解析时使用了 `UnpackIntoInterface` 方法：](#1-在-servicego-中通过-abi-解析时使用了-unpackintointerface-方法)
	- [2. 字段匹配规则：](#2-字段匹配规则-1)
	- [3. 类型兼容性：](#3-类型兼容性)
	- [4. 在合约 ABI 中定义了字段映射：](#4-在合约-abi-中定义了字段映射)


# order匹配

## Solidity

```solidity
struct Asset {
        uint256 tokenId;
        address collection;
        uint96 amount;
    }
    struct Order {
        Side side;
        SaleKind saleKind;
        address maker;
        Asset nft;
        Price price; // unit price of nft
        uint64 expiry;
        uint64 salt;
    }
	```


## Go

```Go
type Order struct {
	Side     uint8
	SaleKind uint8
	Maker    common.Address
	Nft      struct {
		TokenId        *big.Int
		CollectionAddr common.Address
		Amount         *big.Int
	}
	Price  *big.Int
	Expiry uint64
	Salt   uint64
}
```

## 区别 Nft.CollectionAddr字段怎么匹配上的Solidity中的collection字段


Solidity 合约中的 `Asset` 结构体与 Go 中的 `Nft` 字段是通过 ABI 解析自动匹配的。具体匹配过程如下：

### 1. 在 `EasySwapSync/service/orderbookindexer/service.go` 中，通过 ABI 解析日志数据：
```go
var event struct {
    MakeOrder Order
    TakeOrder Order
    FillPrice *big.Int
}

err := s.parsedAbi.UnpackIntoInterface(&event, "LogMatch", log.Data)
```

### 2. 字段匹配规则：
- Solidity 的 `Asset.collection` 对应 Go 的 `Nft.CollectionAddr`
- Solidity 的 `Asset.tokenId` 对应 Go 的 `Nft.TokenId`
- Solidity 的 `Asset.amount` 对应 Go 的 `Nft.Amount`

### 3. 类型转换：
- Solidity 的 `address` 类型自动转换为 Go 的 `common.Address`
- Solidity 的 `uint256`/`uint96` 自动转换为 Go 的 `*big.Int`

### 4. 合约 ABI 定义（在 `contractAbi` 常量中）确保了字段名的正确映射：
```json
{
    "internalType": "structLibOrder.Asset",
    "name": "nft",
    "type": "tuple",
    "components": [
        {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
        },
        {
            "internalType": "address",
            "name": "collection",
            "type": "address"
        },
        {
            "internalType": "uint96",
            "name": "amount",
            "type": "uint96"
        }
    ]
}
```

> 这种匹配是通过 go-ethereum 库的 ABI 解析功能自动完成的，不需要手动映射字段名。只要 Go 结构体的字段名与 Solidity 结构体字段名匹配（忽略大小写），类型兼容，就能正确解析。


# collection 和 collectionAddr名字不一样，也可以匹配上么?


是的，即使字段名不完全一样，也可以匹配上。这是因为 Go 的结构体字段匹配遵循以下规则：

## 1. 在 `service.go` 中，通过 ABI 解析时使用了 `UnpackIntoInterface` 方法：
```go
err := s.parsedAbi.UnpackIntoInterface(&event, "LogMatch", log.Data)
```

## 2. 字段匹配规则：
- Go 结构体字段名会自动匹配 Solidity 结构体字段名（忽略大小写）
- `CollectionAddr` 可以匹配 `collection`，因为：
  - 忽略大小写：CollectionAddr ≈ collection
  - 去掉常见前缀：Addr 是 address 的缩写

## 3. 类型兼容性：
- Solidity 的 `address` 类型
- Go 的 `common.Address` 类型
这两种类型是兼容的，可以自动转换

## 4. 在合约 ABI 中定义了字段映射：
```json
{
    "internalType": "address",
    "name": "collection",
    "type": "address"
}
```

> 这种匹配机制是由 go-ethereum 库的 ABI 解析功能实现的，不需要手动处理字段名的差异。只要类型兼容且字段名相似（忽略大小写和常见前缀/后缀），就能正确解析。

